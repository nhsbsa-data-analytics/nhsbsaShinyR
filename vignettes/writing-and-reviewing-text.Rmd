---
title: "Writing and reviewing text"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{writing-and-reviewing-text}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include = FALSE}
library(shiny)
```

## How text is included in the app

All text is written in markdown (note, __not__ Rmarkdown but just plain old [markdown](https://www.markdownguide.org/cheat-sheet/)). Initially this was tried with Rmarkdown, but this caused various issues that were not a problem with plain markdown.

The text markdown lives in the `inst/app/www/assets/markdown` folder.

```{r}
list.files("../inst/app/www/assets/markdown")
```

Usually there is a single file for each module of the app. This is because in general all the text is first in the module, and followed by the graphical components. Sometimes that is not the case. For example, in the Care Homes update a [module for metrics](https://github.com/nhsbsa-data-analytics/care-home-prescribing-2020-2023/blob/main/R/mod_09_metrics.R) includes several tables interspersed in the text. We did try out using markdown created tables, but they did not look great. In the end we created them with `kable`, and use multiple markdown files. The code is below as an example, with most table code omitted for brevity.

```{r, eval=FALSE}
mod_09_metrics_ui <- function(id) {
  tagList(
    includeMarkdown("inst/markdown/09_metrics_1.md"),
    HTML(
      tibble::tribble(
        ~Patient,       ~Month,     ~`Prescription items`, ~`Unique medicines`,
        #---------------|-----------|--------------------|-----------------
        "A",            "April",      4,                  2,
        "A",            "May",        4,                  2,
        "A",            "June",       4,                  4,
        "A",            "July",       6,                  3,
        "A",            "September",  6,                  3,
        "A",            "November",   6,                  5,
        "B",            "April",      13,                 10,
        "B",            "May",        13,                 10,
        "B",            "August",     10,                 8,
        "C",            "October",    4,                  4
      ) %>%
        knitr::kable("html", caption = "Patient-months example") %>%
        kableExtra::kable_styling(
          bootstrap_options = c("bordered", "striped", "hover", "condensed", "responsive")
        )
    ),
    includeMarkdown("inst/markdown/09_metrics_2.md"),
    HTML(
      tibble::tribble()
    ),
    includeMarkdown("inst/markdown/09_metrics_3.md"),
    HTML(
      tibble::tribble()
    ),
    includeMarkdown("inst/markdown/09_metrics_4.md")
  )
}
```

Each markdown file is included in a modules UI function with the `includeMarkdown` function provided by `{shiny}`. You would think there would be an Rmarkdown version of this, but it seems there is not! This simply converts the markdown into HTML.

```{r}
cat(includeMarkdown("../inst/app/www/assets/markdown/mod_markdown_example.md"))
```

## The writing and review cycle

A common pain point for the team is the process of drafting, reviewing and 'coding' text. There can be many rounds of review and update before a final version of text is agreed. Adding text too early to the app increases the pain, as now the app text and review/draft document (commonly Word with track changes enabled) must be kept in sync. Failing to keep both sources in sync leads to changes being missed and just increases the overhead. At some point however, the text really does need to be added to the app. But there are almost always changes required, despite thinking the version added to the app is the _final_ final version. So there is always going to be some amount of having to juggle multiple sources of text.

## Standardise and automate

We can make the process easier and relatively pain-free by standardising our process. This then allows many of the tasks to be automated. The components and procedures of this process include

1. A 'Word-first' approach, using a set of conventions in how the text is written
2. Automatic conversion between Word and markdown
3. Assisted review of any changes, using file snapshots

### 'Word-first' approach

The idea here is to use Word, with tracking of changes, for as long as possible. Add the text to the app only once you are certain that the text is finalised, or you are forced to add it in order to publish the app (e.g. for review by 3rd parties).

You will need to use a template Word doc in order to use the automation script. This can be generated by knitting `review/styles/draft-styles.Rmd`. You may notice this looks a lot like the standard Rmd template you get when creating a new Rmarkdown document in RStudio, which is exactly what it is! The reason to use this is that the `{officer}` package used in the automation works best with a Word doc that was actually created from Rmd in the first place. There is some scope to redefine some styling if it becomes necessary.

In addition to using the template document when writing the first draft, there are some conventions that need to be followed on which the script depends. All of the (currently) usable syntax is shown on the _Markdown cheat sheet_ page in the example app.

1. Use headings starting from 2nd level (Heading 2 in Word); the 1st level heading will be for the app title, which is not set in the markdown
2. Use __bold__ and _italics_ as required
3. Use __single level__ lists, both ordered and bullets
4. Use the `Consolas` font for mono-spaced text such as code
5. Create hyperlinks where you want a link
    a. External links - just as you would expect
    b. Internal links - construct the URL like `http://127.0.0.1/page?heading` to link to a specific heading of a page, or just `http://127.0.0.1/page` to link to the top of a page
    c. Code links - rarely used but can be done by creating a hyperlink with `Consolas` font
6. Don't include extra line breaks (empty lines) between paragraphs or lists
7. Before converting the doc to markdown, make sure to split the text up into chunks according to the file path you want each section to be saved in, using the relative path from the project root folder and starting each filename with a number corresponding to its order, e.g. `inst/app/www/assets/markdown/01_mod_the_first.md`
8. Anything not explicitly mentioned may or may not work; you can try it out and update this guide!

## Automatic conversion

### Word to markdown...

The conversion makes use of the packages [`{officer}`](https://davidgohel.github.io/officer/) and [`{xml2}`](https://xml2.r-lib.org/), along with some common tidyverse packages.

The general flow of the script is, for each 'chunk' in the document, to

1. Get plain text on each line
2. Use the [xml](https://en.wikipedia.org/wiki/XML) that underlies the Word doc to create a map of the various styles and hyperlinks
3. Transform the plain text using the style maps, into a a version that uses markdown syntax
4. Write the final text to a markdown file

### ...markdown to Word

Conversion from markdown to Word is much easier. The general flow is

1. Read each line of each file into a list
2. Add the file path to the beginning of each list
3. Combine all lists into one list

This list is then written as an Rmarkdown document, and finally rendered as a Word doc using the [`rmarkdown::render`](https://pkgs.rstudio.com/rmarkdown/reference/render.html) and [`officedown::rdocx_document`](https://davidgohel.github.io/officedown/reference/rdocx_document.html) functions. The style document specified by `review/styles/draft-styles.Rmd` is also generated and used in the render step.

## Assisted review

Once the text is first added to the app, as markdown files, there is probably going to be a time when something needs to change, based on feedback or a rethink of what is written. This review process can be made easy with the following steps

1. Make sure to base changes on the current state of the app text, by running the `review/md_to_word.R` script first
2. (First review only) To get the initial snapshots, run the first code block ("generate snapshots") in `review/tests/snapshot_tests.R`; each markdown file should have an expectation
3. Finalise the changes in Word, making sure to accept or reject every change
4. Run the second code block ("markdown text is as expected") in `review/tests/snapshot_tests.R`
5. Run the diff tool with `testthat::snapshot_review('snapshot_tests/', "review/tests")`
6. For each file with changes
    a. If __all__ changes in a file are as intended, then choose the 'Accept' option
    b. If there are unintended changes, fix these in the associated markdown file in `review/temp` (simple copy and paste from the diff viewer works)
    c. If you could not 'Accept' a file because some changes were unintended, instead click 'Skip'
7. Once you have finished with the checking and fixing, close the diff viewer
8. Re-run the snapshot tests __BUT MAKE SURE__ to comment out `source("review/scripts/word_to_md.R")` or you will overwrite your amendments and have to redo them! (for extra safety, you could rename the Word doc after step 4, which will make the test error out). You should expect no differences to be found now, but if there are then repeat step 6 to 8 until none are found.
9. Once all is as it should be, you can safely copy the revised markdown files in the `review/temp` folder over the source markdown files for the app in `/inst/app/www/assets/markdown`. __MAKE SURE__ to uncomment `source("review/scripts/word_to_md.R")` in the "markdown text is as expected" code block, if you had to make any fixes, so it is ready for next review cycle.

The snapshot tests file has extensive comments to follow.

NOTE: The process outlined could be improved, perhaps by using functions rather than scripts and a test file that requires some manual management of which code to run; hopefully this will get us started and the best process will emerge as we go.
