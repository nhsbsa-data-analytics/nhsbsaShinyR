---
title: "Writing and reviewing text"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Writing and reviewing text}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include = FALSE}
library(shiny)
```

## How text is included in the app

All text is written in markdown (note, __not__ Rmarkdown but just plain old [markdown](https://www.markdownguide.org/cheat-sheet/)). Initially this was tried with Rmarkdown, but this caused various issues that were not a problem with plain markdown.

The text markdown lives in the `inst/app/www/assets/markdown` folder.

```{r}
list.files("../inst/app/www/assets/markdown")
```

Usually there is a single file for each module of the app. This is because in general all the text is first in the module, and followed by the graphical components. Sometimes that is not the case. For example, in the Care Homes update a [module for metrics](https://github.com/nhsbsa-data-analytics/care-home-prescribing-2020-2023/blob/main/R/mod_10_metrics.R) includes several tables interspersed in the text. We did try out using markdown created tables, but they did not look great. In the end we created them with `kable`, and use multiple markdown files. The code is below as an example, with most table code omitted for brevity.

```{r, eval=FALSE}
mod_09_metrics_ui <- function(id) {
  tagList(
    includeMarkdown("inst/markdown/09_metrics_1.md"),
    HTML(
      tibble::tribble(
        ~Patient,       ~Month,     ~`Prescription items`, ~`Unique medicines`,
        #---------------|-----------|--------------------|-----------------
        "A",            "April",      4,                  2,
        "A",            "May",        4,                  2,
        "A",            "June",       4,                  4,
        "A",            "July",       6,                  3,
        "A",            "September",  6,                  3,
        "A",            "November",   6,                  5,
        "B",            "April",      13,                 10,
        "B",            "May",        13,                 10,
        "B",            "August",     10,                 8,
        "C",            "October",    4,                  4
      ) %>%
        knitr::kable("html", caption = "Patient-months example") %>%
        kableExtra::kable_styling(
          bootstrap_options = c("bordered", "striped", "hover", "condensed", "responsive")
        )
    ),
    includeMarkdown("inst/markdown/09_metrics_2.md"),
    HTML(
      tibble::tribble()
    ),
    includeMarkdown("inst/markdown/09_metrics_3.md"),
    HTML(
      tibble::tribble()
    ),
    includeMarkdown("inst/markdown/09_metrics_4.md")
  )
}
```

Each markdown file is included in a modules UI function with the `includeMarkdown` function provided by `{shiny}`. You would think there would be an Rmarkdown version of this, but it seems there is not! This simply converts the markdown into HTML.

## The writing and review cycle

A common pain point for the team is the process of drafting, reviewing and 'coding' text. There can be many rounds of review and update before a final version of text is agreed. Adding text too early to the app increases the pain, as now the app text and review/draft document (commonly Word with track changes enabled) must be kept in sync. Failing to keep both sources in sync leads to changes being missed and just increases the overhead. At some point however, the text really does need to be added to the app. But there are almost always changes required, despite thinking the version added to the app is the _final_ final version. So there is always going to be some amount of having to juggle multiple sources of text.

## Standardise and automate

We can make the process easier and relatively pain-free by standardising our process. This then allows many of the tasks to be automated. The components and procedures of this process include

1. A 'Word-first' approach, using a set of conventions in how the text is written
2. Automatic conversion between Word and markdown
3. Assisted review of any changes, using file snapshots

### 'Word-first' approach

The idea here is to use Word, with tracking of changes, for as long as possible. Add the text to the app only once you are certain that the text is finalised, or you are forced to add it in order to publish the app (e.g. for review by 3rd parties).

You will need to use a template Word doc in order to use the automation script. This can be generated by knitting `review/styles/draft-styles.Rmd`. The reason to use this is that the `{officer}` package used in the automation works best with a Word doc that was actually created from Rmd in the first place. There is some scope to redefine some styling if it becomes necessary. 

The template could be pre-knitted and ready to use. However, the risk is that a change is made that impacts the template, but an old version of the template is used.

In addition to using the template document when writing the first draft, there are some conventions that need to be followed on which the script depends. All of the (currently) usable syntax is shown on the _Markdown cheat sheet_ page in the example app.

1. Use headings starting from 1st to 4th level (Heading n, in Word)
2. Use __bold__ and _italics_ as required
3. Use __single level__ lists, both ordered and bullets
4. Use the `Consolas` font for mono-spaced text such as code
5. Create hyperlinks where you want a link
    a. External links - just as you would expect
    b. Internal links - construct the URL like `http://127.0.0.1/page?heading` to link to a specific heading of a page, or just `http://127.0.0.1/page` to link to the top of a page
    c. Code links - rarely used but can be done by creating a hyperlink with `Consolas` font
6. Don't include extra line breaks (empty lines) between paragraphs or lists
7. Before converting the doc to markdown, make sure to split the text up into chunks according to the file path you want each section to be saved in, using the relative path from the project root folder and starting each filename with a number corresponding to its order, e.g. `inst/app/www/assets/markdown/01_mod_the_first.md`
8. Anything not explicitly mentioned may or may not work; you can try it out and update this guide!

## Automatic conversion

### Word to markdown...

The conversion makes use of the packages [`{officer}`](https://davidgohel.github.io/officer/) and [`{xml2}`](https://xml2.r-lib.org/), along with some common tidyverse packages.

Running `word_to_md()` will, for each 'chunk' in the document

1. Get plain text on each line
2. Use the [xml](https://en.wikipedia.org/wiki/XML) that underlies the Word doc to create a map of the various styles and hyperlinks
3. Transform the plain text using the style maps, into a a version that uses markdown syntax
4. Write the final text to a markdown file

### ...markdown to Word

Conversion from markdown to Word is much easier. Running `md_to_word()` will, for each markdown file

1. Read each line into a list
2. Add the file path to the beginning of each list
3. Combine all lists into one list

This list is then written as an Rmarkdown document, and finally rendered as a Word doc using the [`rmarkdown::render`](https://pkgs.rstudio.com/rmarkdown/reference/render.html) and [`officedown::rdocx_document`](https://davidgohel.github.io/officedown/reference/rdocx_document.html) functions. The style document specified by `review/styles/draft-styles.Rmd` is also generated and used in the render step.

## Assisted review

Once the text is first added to the app, as markdown files, there is probably going to be a time when something needs to change, based on feedback or a rethink of what is written. Using the automation provided by the review functions makes keeping the draft text and the app text synced quicker, easier and less error-prone.

When starting from scratch, with no text yet written, the end-to-end process follows. If you already have text written in markdown format (ensure to use the conventions as laid out in the _Markdown cheat sheet_ page in the example app), you can generate the Word version of it following step 8.

The review cycle comprises steps 4 to 8.

1. Generate the initial Word document by running `gen_template_doc()`. The Word doc will be saved in the `inst/review` folder as `review.docx`.
2. Write the initial draft of text in `review.docx`, using Word's review functionality to track changes and comments. It is important to use the conventions laid out in ['Word-first' approach](127.0.0.1/#word-first-approach), as without these the functions may give unexpected results. Keep it in Word for as long as possible!
3. When you get to a point when you _have_ to deploy the app with the text, run `word_to_md()`. With the default arguments, the generated markdown files are saved to `inst/review/temp`. From this point on, the app text and the Word text need to be synced as changes are agreed. On the first run of `word_to_md` the initial snapshot files will be automatically created in `inst/review/tests/_snaps/review_md`. These snapshots will be used to compare future changes to, and can be updated as the text changes and is added to the app. Note that, by default, if any existing markdown is in `inst/review/tests/_snaps/review_md` folder, the initial snaps will not be created, so ensure the folder is either not present or empty. You will see a warning if unable to write the snapshot files due to pre-existing snapshots.
4. If the text now never changes, you are lucky! But usually there will be multiple rounds of adjustments before the final text is agreed. After the previous step, the text in `review.docx` precisely mirrors what is in the app. Continue to use `review.docx` as your _staging area_ (similar to how git has the `add` command to stage changes). Whenever you want to _commit_ (in git terminology, again) changes to the app run `word_to_md()` again, but follow it with a run of `review_md_dir()`. When the latter is run, it will compare the newly generated markdown against the previously saved snapshots. 
5. You should now review the new versions of the markdown files. Reviewing them carefully in this way makes it much less likely that something unintended is being changed, such as typos and misspellings. Additionally, if you expected some change but it has not been included, then this is another opportunity to catch the omission. Running `review_md_diff()` will open an interactive diff. This allows to reject, skip or accept a change. Currently each decision is on a per file basis.
    - Reject  
      : If you reject changes to a file, you will need to make amendments to the temporary markdown file. You can make the changes first, with the diff open, and then reject. This allows you to see easily just what is not as intended, and allows for copying from the diff viewer and pasting into the temporary markdown as a simple way to revert any change. Note that you will need to reject when __not all__ changes are as desired.
    - Skip 
      : If you are unsure whether changes to a file are not quite right, then use the skip option. You can come back to it later, either in the same review session, or by re-running `review_md_diff()` once you have checked further.
    - Accept 
      : If __all__ changes are correct then accept them. This will update the snapshot for that file.
6. You can re-run `review_md_dir()` and `review_md_diff()` as much as is needed, until all changes are correct. For example, you find all changes look good, except for one file with typos and one file that you want to check the wording of. The review cycle might look like
    - `review_md_dir()` then `review_md_diff()`
    - Accept all good files
    - Skip the file with possibly poor wording
    - Fix the typos in one file, then reject it
    - Close the diff viewer
    - Check with team on wording, better wording agreed on
    - Edit wording in one file
    - `review_md_dir()` then `review_md_diff()`
    - All typos caught, accept file
    - Wording is OK now, so accept the last file
7. Now the review is finished, you should run `update_md()`. This simply replaces the markdown in `/inst/app/www/assets/markdown` with those in `inst/review/temp`.
8. The last step is to regenerate the review _staging_ Word doc, with a call to `md_to_word()`. This will replace `review.docx` in `inst/review`, but will keep a renamed copy of the current one, as `prev-review.docx` for safety (which __will__ replace an existing `prev-review.docx`).
